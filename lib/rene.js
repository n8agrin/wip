// Generated by CoffeeScript 1.3.3
(function() {
  var rene,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  rene = {};

  if (typeof module !== "undefined" && module !== null) {
    module.exports = rene;
  } else {
    this.wip = rene;
  }

  rene.utils = {
    translate: function(x, y) {
      return "translate(" + x + "," + y + ")";
    },
    naiveFill: function(data) {
      var dataXIndexed, dataset, datasetXIndexed, idx, kind, mapData, newDataset, newSets, point, points, samples, seenXValues, x, _i, _j, _k, _len, _len1, _len2, _name;
      if (!data.some(function(dataset) {
        return dataset.length;
      })) {
        return data;
      }
      samples = data.map(function(dset) {
        return dset[0];
      });
      if (samples[0].x instanceof Date) {
        kind = "date";
      } else {
        kind = typeof samples[0].x;
      }
      data = data.map(function(dset) {
        return dset.map(function(p) {
          var k, n, v;
          n = {};
          for (k in p) {
            v = p[k];
            n[k] = v;
          }
          return n;
        });
      });
      if (kind === "date" || kind === "number") {
        mapData = data.map(function(dset, i) {
          return dset.reduce((function(p, c) {
            var x;
            x = c.x.valueOf();
            if (!p[x]) {
              p[x] = c;
            } else {
              p[x].y += c.y;
            }
            return p;
          }), {});
        });
        points = d3.merge(mapData.map(function(dset) {
          return Object.keys(dset).map(function(x) {
            return parseInt(x, 10);
          });
        })).sort(function(a, b) {
          if (a < b) {
            return -1;
          } else if (a === b) {
            return 0;
          } else {
            return 1;
          }
        }).reduce((function(p, c) {
          if (p.last !== c) {
            p.push(c);
            p.last = c;
          }
          return p;
        }), []);
        newSets = mapData.map(function(dset, i) {
          return points.map(function(p, j) {
            return dset[p] || {
              x: parseInt(p, 10),
              y: 0
            };
          });
        });
        if (kind === "date") {
          newSets.forEach(function(dset) {
            return dset.forEach(function(p) {
              return p.x = new Date(p.x.valueOf());
            });
          });
        }
      } else {
        seenXValues = {};
        dataXIndexed = [];
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          dataset = data[_i];
          datasetXIndexed = {};
          for (idx = _j = 0, _len1 = dataset.length; _j < _len1; idx = ++_j) {
            point = dataset[idx];
            seenXValues[_name = point.x] || (seenXValues[_name] = idx);
            datasetXIndexed[point.x] = point;
          }
          dataXIndexed.push(datasetXIndexed);
        }
        newSets = [];
        for (_k = 0, _len2 = dataXIndexed.length; _k < _len2; _k++) {
          dataset = dataXIndexed[_k];
          newDataset = [];
          for (x in seenXValues) {
            idx = seenXValues[x];
            newDataset[idx] = dataset[x] || {
              x: x,
              y: 0
            };
          }
          newSets.push(newDataset);
        }
      }
      newSets.forEach(function(dset, i) {
        return dset.forEach(function(p) {
          var k, v, _ref, _results;
          _ref = samples[i];
          _results = [];
          for (k in _ref) {
            v = _ref[k];
            if (!(p[k] != null)) {
              _results.push(p[k] = v);
            } else {
              _results.push(void 0);
            }
          }
          return _results;
        });
      });
      return newSets;
    }
  };

  rene.Chart = (function() {
    var callable;

    callable = function(selection) {
      var chart;
      chart = this;
      return selection.each(function(data) {
        chart.setContainer(this);
        chart.initChart(data);
        return chart.render();
      });
    };

    function Chart() {
      this.apply = __bind(this.apply, this);

      this.call = __bind(this.call, this);

      this.setDimensionsFromSelection = __bind(this.setDimensionsFromSelection, this);

      this.render = __bind(this.render, this);

      this.initChart = __bind(this.initChart, this);

      this.trainScaleDomains = __bind(this.trainScaleDomains, this);

      this.trainScaleRanges = __bind(this.trainScaleRanges, this);

      this.initLayerGroups = __bind(this.initLayerGroups, this);

      this.positionData = __bind(this.positionData, this);

      this.initScales = __bind(this.initScales, this);

      this.initSVG = __bind(this.initSVG, this);

      this.resetXYScales = __bind(this.resetXYScales, this);

      this.setContainer = __bind(this.setContainer, this);

      this.setScale = __bind(this.setScale, this);
      this.layers = [];
      this.xAxis = d3.svg.axis().orient('bottom');
      this.yAxis = d3.svg.axis().orient('left');
      this.xAxisLabel = null;
      this.yAxisLabel = null;
      this.xGrid = d3.svg.axis();
      this.yGrid = d3.svg.axis();
      this.margin = {
        top: 20,
        bottom: 20,
        left: 30,
        right: 20
      };
      this.containerSize = [0, 0];
      this.panelSize = [0, 0];
      this.container = d3.select();
      this.svg = d3.select();
      this.layerGroups = d3.select();
      this.scales = {};
      this.originalScales = {};
      this.rangeFn = "rangeRoundBands";
    }

    Chart.prototype.setScale = function(aes, scale) {
      this.scales[aes] = scale;
      return this.originalScales[aes] = scale.copy();
    };

    Chart.prototype.setContainer = function(container) {
      this.container = d3.select(container);
      return this.setDimensionsFromSelection(container);
    };

    Chart.prototype.resetXYScales = function() {
      var name, _i, _len, _ref, _results;
      _ref = ['x', 'y'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        name = _ref[_i];
        if (this.scales[name] && this.originalScales[name]) {
          _results.push(this.scales[name] = this.originalScales[name].copy());
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Chart.prototype.initSVG = function(data) {
      var gEnter;
      this.svg = this.container.selectAll('svg').data([data]);
      gEnter = this.svg.enter().append('svg').attr('class', 'plot').attr('width', this.containerSize[0]).attr('height', this.containerSize[1]).append('g').attr('transform', rene.utils.translate(this.margin.left, this.margin.top));
      gEnter.append('g').attr('class', 'x grid');
      gEnter.append('g').attr('class', 'y grid');
      gEnter.append('g').attr('class', 'geoms');
      gEnter.append('g').attr('class', 'x axis');
      return gEnter.append('g').attr('class', 'y axis');
    };

    Chart.prototype.initScales = function() {
      var aes, layer, scale, _i, _len, _ref, _results;
      _ref = this.layers;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        layer = _ref[_i];
        _results.push((function() {
          var _ref1, _results1;
          _ref1 = layer.scales;
          _results1 = [];
          for (aes in _ref1) {
            scale = _ref1[aes];
            _results1.push(this.scales[aes] || this.setScale(aes, scale()));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Chart.prototype.positionData = function(data) {
      var dataset, i, _i, _len, _results;
      _results = [];
      for (i = _i = 0, _len = data.length; _i < _len; i = ++_i) {
        dataset = data[i];
        _results.push(this.layers[i].mapData(dataset));
      }
      return _results;
    };

    Chart.prototype.initLayerGroups = function(data) {
      this.layerGroups = this.svg.select('g.geoms').selectAll('g.layer').data(data);
      return this.layerGroups.enter().append('g').attr('class', 'layer').attr('id', function(d, i) {
        return "layer" + i;
      });
    };

    Chart.prototype.trainScaleRanges = function() {
      var _ref, _ref1, _ref2;
      if (((_ref = this.scales.x) != null ? _ref[this.rangeFn] : void 0) != null) {
        this.scales.x[this.rangeFn]([0, this.panelSize[0]], 0.1);
      } else {
        if ((_ref1 = this.scales.x) != null) {
          _ref1.range([0, this.panelSize[0]]);
        }
      }
      return (_ref2 = this.scales.y) != null ? _ref2.range([0, this.panelSize[1]]) : void 0;
    };

    Chart.prototype.trainScaleDomains = function(data) {
      var aesValues, aesthetic, dataGroup, dataset, point, scale, scaleData, _i, _j, _k, _len, _len1, _len2, _ref, _ref1, _results;
      _ref = this.scales;
      _results = [];
      for (aesthetic in _ref) {
        scale = _ref[aesthetic];
        scaleData = scale.domain().concat();
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          dataset = data[_i];
          for (_j = 0, _len1 = dataset.length; _j < _len1; _j++) {
            dataGroup = dataset[_j];
            if (scale.rangeBand) {
              for (_k = 0, _len2 = dataGroup.length; _k < _len2; _k++) {
                point = dataGroup[_k];
                if (_ref1 = point[aesthetic], __indexOf.call(scaleData, _ref1) < 0) {
                  scaleData.push(point[aesthetic]);
                }
              }
            } else {
              if (aesthetic === 'y') {
                aesValues = (function() {
                  var _l, _len3, _results1;
                  _results1 = [];
                  for (_l = 0, _len3 = dataGroup.length; _l < _len3; _l++) {
                    point = dataGroup[_l];
                    _results1.push(point[aesthetic] + (point[aesthetic + '0'] || 0));
                  }
                  return _results1;
                })();
              } else {
                aesValues = (function() {
                  var _l, _len3, _results1;
                  _results1 = [];
                  for (_l = 0, _len3 = dataGroup.length; _l < _len3; _l++) {
                    point = dataGroup[_l];
                    _results1.push(point[aesthetic]);
                  }
                  return _results1;
                })();
              }
              scaleData = d3.extent(scaleData.concat(aesValues));
            }
          }
        }
        _results.push(scale.domain(scaleData));
      }
      return _results;
    };

    Chart.prototype.renderLayers = function() {
      var _this = this;
      return (function(_arg) {
        var layers, panelSize, scales;
        layers = _arg.layers, scales = _arg.scales, panelSize = _arg.panelSize;
        return _this.layerGroups.each(function(data, idx) {
          return d3.transition(d3.select(this)).call(layers[idx].render, scales, panelSize[0], panelSize[1]);
        });
      })(this);
    };

    Chart.prototype.moveLayers = function() {
      var _this = this;
      return (function(_arg) {
        var layers, margin, panelSize, scales;
        layers = _arg.layers, scales = _arg.scales, panelSize = _arg.panelSize, margin = _arg.margin;
        return _this.layerGroups.each(function(data, idx) {
          return d3.transition(d3.select(this)).call(layers[idx].move, panelSize[0], panelSize[1], margin);
        });
      })(this);
    };

    Chart.prototype.renderScales = function() {
      var panelSize, yAxisScale;
      panelSize = this.panelSize;
      if (this.scales.x && this.xAxis) {
        this.xAxis.scale(this.scales.x);
        this.svg.select('.x.axis').attr('transform', rene.utils.translate(0, panelSize[1])).call(this.xAxis);
      }
      if (this.scales.y && this.yAxis) {
        yAxisScale = this.scales.y.copy();
        yAxisScale.range(this.scales.y.range().concat().reverse());
        this.yAxis.scale(yAxisScale);
        return this.svg.select('.y.axis').call(this.yAxis);
      }
    };

    Chart.prototype.renderGrid = function() {
      var panelSize, yAxisScale;
      panelSize = this.panelSize;
      if (this.xGrid) {
        this.xGrid.scale(this.scales.x).tickSize(-panelSize[1], -panelSize[1], -panelSize[1]).orient('bottom');
        this.svg.select('g.x.grid').attr('transform', rene.utils.translate(0, panelSize[1])).call(this.xGrid);
        this.svg.selectAll('g.x.grid text, g.x.grid path.domain').remove();
      }
      if (this.yGrid) {
        yAxisScale = this.scales.y.copy();
        yAxisScale.range(this.scales.y.range().concat().reverse());
        this.yGrid.scale(yAxisScale).tickSize(-panelSize[0], -panelSize[0], -panelSize[0]).orient('left');
        this.svg.select('g.y.grid').call(this.yGrid);
        return this.svg.selectAll('g.y.grid text, g.y.grid path.domain').remove();
      }
    };

    Chart.prototype.renderLabels = function() {
      var xLabel, xLabelEnter, yLabel, yLabelEnter;
      if (this.xAxisLabel) {
        xLabel = this.svg.select('.x.axis').selectAll('text.label').data([this.xAxisLabel]);
        xLabelEnter = xLabel.enter().append('text').classed('label', true);
        xLabel.text(function(d) {
          return d;
        }).attr('transform', rene.utils.translate(0, 34));
      }
      if (this.yAxisLabel) {
        yLabel = this.svg.select('.y.axis').selectAll('text.label').data([this.yAxisLabel]);
        yLabelEnter = yLabel.enter().append('text').classed('label', true);
        return yLabel.text(function(d) {
          return d;
        }).attr("transform", rene.utils.translate(-40, this.panelSize[1]) + " rotate(270, 0, 0)");
      }
    };

    Chart.prototype.initChart = function(data) {
      this.resetXYScales();
      this.initSVG(data);
      this.initScales();
      data = this.positionData(data);
      this.initLayerGroups(data);
      this.trainScaleRanges();
      return this.trainScaleDomains(data);
    };

    Chart.prototype.render = function() {
      this.renderLayers();
      this.renderScales();
      this.renderGrid();
      this.renderLabels();
      return this.moveLayers();
    };

    Chart.prototype.setDimensionsFromSelection = function(selection) {
      this.containerSize = [selection.clientWidth, selection.clientHeight];
      this.panelSize[0] = selection.clientWidth - (this.margin.left + this.margin.right);
      return this.panelSize[1] = selection.clientHeight - (this.margin.top + this.margin.bottom);
    };

    Chart.prototype.call = function() {
      return callable.apply(this, arguments);
    };

    Chart.prototype.apply = function() {
      return callable.apply(this, arguments);
    };

    return Chart;

  })();

  rene.Layer = (function() {

    function Layer() {
      this.x = function(d) {
        return d[0];
      };
      this.y = function(d) {
        return d[1];
      };
      this.color = function(d) {
        return d[2];
      };
      this.size = function(d) {
        return d[3];
      };
      this.group = function(d) {
        return d[2];
      };
    }

    Layer.prototype.position = Object;

    Layer.prototype.move = function() {};

    Layer.prototype.aesthetics = function() {
      return [['x', this.x], ['y', this.y], ['color', this.color], ['group', this.group]];
    };

    Layer.prototype.mapData = function(dataset) {
      var aesthetic, newPoint, newPoints, point, _i, _j, _len, _len1, _ref;
      newPoints = [];
      for (_i = 0, _len = dataset.length; _i < _len; _i++) {
        point = dataset[_i];
        newPoint = {};
        _ref = this.aesthetics();
        for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {
          aesthetic = _ref[_j];
          newPoint[aesthetic[0]] = aesthetic[1](point);
        }
        newPoints.push(newPoint);
      }
      return this.position(this.groupData(newPoints));
    };

    Layer.prototype.groupData = function(dataset) {
      var k, v, _ref, _ref1, _results;
      if ((_ref = dataset[0]) != null ? _ref.group : void 0) {
        _ref1 = d3.nest().key(function(d) {
          return d.group;
        }).map(dataset);
        _results = [];
        for (k in _ref1) {
          v = _ref1[k];
          _results.push(v);
        }
        return _results;
      } else {
        return [dataset];
      }
    };

    return Layer;

  })();

  rene.Point = (function(_super) {

    __extends(Point, _super);

    function Point() {
      this.render = __bind(this.render, this);
      Point.__super__.constructor.apply(this, arguments);
      this.defaultSize = 2;
    }

    Point.prototype.scales = {
      x: d3.scale.linear,
      y: d3.scale.linear,
      color: d3.scale.category20,
      size: d3.scale.linear
    };

    Point.prototype.render = function(group, scales, width, height) {
      var layer;
      layer = this;
      group.classed('point', true);
      return group.each(function(d) {
        var circleGroups, circles, circlesEnter, circlesExit, circlesUpdate;
        circleGroups = d3.select(this).selectAll('g.group').data(Object);
        circleGroups.enter().append('g').attr('class', 'group');
        d3.transition(circleGroups.exit()).remove();
        circles = circleGroups.selectAll('circle').data(Object);
        circlesEnter = circles.enter().append('circle').attr('opacity', 1e-6);
        circlesExit = d3.transition(circles.exit()).attr('opacity', 0).remove();
        circlesUpdate = d3.transition(circles).attr('opacity', 1);
        circlesUpdate.attr('cx', function(point) {
          return scales.x(point.x);
        }).attr('cy', function(point) {
          return height - scales.y(point.y);
        }).attr('r', function(point) {
          return layer.defaultSize;
        });
        if (scales.color) {
          return circlesUpdate.style('fill', function(point) {
            return scales.color(point.color);
          });
        }
      });
    };

    return Point;

  })(rene.Layer);

  rene.Line = (function(_super) {

    __extends(Line, _super);

    function Line() {
      this.render = __bind(this.render, this);
      Line.__super__.constructor.apply(this, arguments);
      this.interpolate = 'monotone';
    }

    Line.prototype.scales = {
      x: d3.time.scale,
      y: d3.scale.linear,
      color: d3.scale.category20,
      size: d3.scale.linear
    };

    Line.prototype.render = function(group, scales, width, height) {
      var path;
      path = d3.svg.line().interpolate(this.interpolate).x(function(point) {
        return scales.x(point.x);
      }).y(function(point) {
        return height - scales.y(point.y);
      });
      group.classed('line', true);
      return group.each(function(dataset) {
        var lineGroups, lines, linesEnter, linesExit, linesUpdate;
        lineGroups = d3.select(this).selectAll('g').data(dataset);
        lineGroups.enter().append('g');
        d3.transition(lineGroups.exit()).remove();
        lines = lineGroups.selectAll('path').data(function(pathset) {
          return [pathset];
        });
        linesEnter = lines.enter().append('path');
        linesExit = d3.transition(lines.exit()).remove();
        linesUpdate = d3.transition(lines);
        linesUpdate.attr("d", path);
        if (scales.color) {
          return linesUpdate.style('stroke', function(pathset) {
            if (pathset[0] != null) {
              return scales.color(pathset[0].color);
            }
          });
        }
      });
    };

    return Line;

  })(rene.Layer);

  rene.Area = (function(_super) {

    __extends(Area, _super);

    function Area() {
      this.render = __bind(this.render, this);
      Area.__super__.constructor.apply(this, arguments);
      this.y0 = d3.functor(0);
      this.y1 = d3.functor(0);
      this.interpolate = d3.functor('monotone');
      this.stack = d3.layout.stack();
    }

    Area.prototype.position = function(data) {
      return this.stack(rene.utils.naiveFill(data));
    };

    Area.prototype.aesthetics = function() {
      var aes;
      aes = Area.__super__.aesthetics.call(this);
      aes.push(['y0', this.y0]);
      aes.push(['y1', this.y1]);
      return aes;
    };

    Area.prototype.scales = {
      x: d3.scale.linear,
      y: d3.scale.linear,
      color: d3.scale.category20,
      size: d3.scale.linear
    };

    Area.prototype.render = function(group, scales, width, height) {
      var pathFn;
      pathFn = d3.svg.area().interpolate(this.interpolate()).x(function(d) {
        return scales.x(d.x);
      }).y0(function(d) {
        return height - scales.y(d.y0);
      }).y1(function(d) {
        return height - scales.y(d.y + d.y0);
      });
      group.classed('area', true);
      return group.each(function(data) {
        var areaGroups, areas, areasEnter, areasExit, areasUpdate;
        areaGroups = d3.select(this).selectAll('g.area').data(Object);
        areaGroups.enter().append('g').attr('class', 'area');
        d3.transition(areaGroups.exit()).remove();
        areas = areaGroups.selectAll('path').data(function(pathset) {
          return [pathset];
        });
        areasEnter = areas.enter().append('path');
        areasExit = d3.transition(areas.exit()).remove();
        areasUpdate = d3.transition(areas);
        areasUpdate.attr('d', pathFn);
        if (scales.color) {
          return areasUpdate.style('fill', function(pathset) {
            if (pathset[0] != null) {
              return scales.color(pathset[0].color);
            }
          });
        }
      });
    };

    return Area;

  })(rene.Layer);

  rene.Bar = (function(_super) {

    __extends(Bar, _super);

    function Bar() {
      this.render = __bind(this.render, this);
      Bar.__super__.constructor.apply(this, arguments);
      this.ranger = d3.range;
      this.step = d3.functor(1);
      this.stack = d3.layout.stack();
      this.x0 = d3.functor(0);
      this.x1 = d3.functor(0);
    }

    Bar.prototype.scales = {
      x: d3.scale.ordinal,
      y: d3.scale.linear,
      color: d3.scale.category20
    };

    Bar.prototype.aesthetics = function() {
      var aes;
      aes = Bar.__super__.aesthetics.call(this);
      aes.push(['x0', this.x0]);
      aes.push(['x1', this.x1]);
      return aes;
    };

    Bar.prototype.position = function(data) {
      return this.stack(rene.utils.naiveFill(data));
    };

    Bar.prototype.barWidth = function(scales) {
      var bars, maxDomain, maxRange, minDomain, minRange, width, _ref, _ref1;
      if (scales.x.rangeBand) {
        return scales.x.rangeBand();
      } else {
        _ref = scales.x.domain(), minDomain = _ref[0], maxDomain = _ref[1];
        _ref1 = scales.x.range(), minRange = _ref1[0], maxRange = _ref1[1];
        bars = this.ranger(minDomain, maxDomain, this.step());
        width = 1;
        if (((maxRange - minRange) / bars.length) > 1) {
          width = d3.scale.ordinal().domain(bars).rangeRoundBands(scales.x.range(), 0.2).rangeBand();
        }
        return width;
      }
    };

    Bar.prototype.render = function(group, scales, width, height) {
      var barWidth;
      barWidth = this.barWidth(scales);
      group.classed('bar', true);
      return group.each(function(dataset, i) {
        var barGroups, bars, barsEnter, barsExit, barsUpdate, groupDomain, groupedRangeBands;
        if (dataset.length) {
          groupDomain = d3.range(d3.max(dataset[dataset.length - 1], function(d) {
            return d.x1;
          }) + 1);
        } else {
          groupDomain = 0;
        }
        groupedRangeBands = d3.scale.ordinal().domain(groupDomain).rangeRoundBands([0, barWidth]);
        barGroups = d3.select(this).selectAll('g').data(dataset);
        barGroups.enter().append('g');
        d3.transition(barGroups).attr("transform", function(d, i) {
          return rene.utils.translate(groupedRangeBands(i), 0);
        });
        d3.transition(barGroups.exit()).remove();
        bars = barGroups.selectAll('rect').data(Object);
        barsEnter = bars.enter().append('rect');
        barsExit = d3.transition(bars.exit()).remove();
        console.log('grb', groupedRangeBands.rangeBand());
        barsUpdate = d3.transition(bars).attr('x', function(point) {
          return scales.x(point.x);
        }).attr('y', function(point) {
          return height - scales.y(Math.max(point.y0, point.y + point.y0));
        }).attr('height', function(point) {
          return Math.abs(scales.y(point.y) - scales.y(0));
        }).attr('width', function() {
          return groupedRangeBands.rangeBand();
        });
        if (scales.color) {
          return barsUpdate.style('fill', function(point) {
            return scales.color(point.color);
          });
        }
      });
    };

    return Bar;

  })(rene.Layer);

  rene.Pie = (function(_super) {

    __extends(Pie, _super);

    function Pie() {
      this.move = __bind(this.move, this);

      this.render = __bind(this.render, this);
      this.location = 'center';
      this.arc = d3.svg.arc().innerRadius(0).outerRadius(200);
      this.pie = d3.layout.pie().value(function(d) {
        return d.value;
      });
      this.color = Object;
      this.value = Object;
      this.pullLeft = 20;
    }

    Pie.prototype.scales = {
      color: d3.scale.category20
    };

    Pie.prototype.aesthetics = function() {
      return [['value', this.value], ['color', this.color]];
    };

    Pie.prototype.render = function(group, scales, width, height) {
      var layer;
      layer = this;
      group.classed('pie', true);
      return group.each(function(d, i) {
        var arcs, arcsEnter, arcsExit, arcsUpdate, pied;
        pied = layer.pie(d[0]);
        arcs = d3.select(this).selectAll('path.arc').data(pied);
        arcsEnter = arcs.enter().append('path').attr('class', 'arc').style('opacity', 1e-6);
        arcsExit = d3.transition(arcs.exit()).style('opacity', 1e-6).remove();
        arcsUpdate = d3.transition(arcs).style('opacity', 1);
        return arcsUpdate.attr('d', function(d, i) {
          return layer.arc(d);
        }).attr('fill', function(d, i) {
          return scales.color(d.data.color);
        });
      });
    };

    Pie.prototype.move = function(layer, width, height, margins) {
      var left, radius, top;
      switch (this.location) {
        case "center":
          return layer.attr("transform", rene.utils.translate(width / 2, height / 2));
        case "left":
          radius = (this.arc.outerRadius())();
          left = radius - this.pullLeft;
          top = radius;
          return layer.attr("transform", rene.utils.translate(left, top));
      }
    };

    return Pie;

  })(rene.Layer);

}).call(this);
